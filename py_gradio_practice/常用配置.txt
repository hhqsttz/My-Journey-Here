启动方式：
冷启动：python app.py
热启动：gradio app.py (此时的接口应该改名为demo)此方式代码改动，界面也随之而动
1.常用属性：
    info：类似describe
    label：标签
    value：“默认值”
2.常用基础组件：
描述组件：
    Title： “标题”

    Description：“总体的描述”

    Article：“文章描述” 在例子的下面

多模态组件可作为输入/输出组件：
    File()：文件
    Image(): 图片
    Video()：视频
    Audio()：音频
    Text(lines=行数)： 文本
    Markdown("""
              # h1
              ## h2
              ### h3
              """ ): 特殊文本
工具组件：
    Radio([参数]，value) 单选按钮

    State():用于存储数据，相当于一个进程的容器。

    Checkbox([参数]，value) True/False 复选框
    CheckboxGrop()         返回列表     0/1/多个

    Slider(起始值，终止值，value=“默认值”) 滑动轨

    Dropdown([参数]，value，multiselect=true) 可多选下拉框

    Example：[对应函数的输入数据列表] 一般放在最下面来提供实例

    Examples(examples=[],input组件):示例组件，点击可以直接将示例赋值给输入组件

前端语言组件：
    HTML():
    CSS():

plot展示组件：
    查文档

3.接口（已经封装好的布局，内置很多组件）：
    gr.Interface(fn,intput,output) 基础的interface

    gr.TabbedInterface(            实现了一个界面多个接口
        Interface_list=[接口一，接口二，...]
        Interface_name=["接口一标题"，"接口二标题"]
        )

    def echo(message,history，..附加输入)

        流式响应输出
        for i in res
            time.sleep(0.1) 模拟响应
        yield res[:i+1]


    gr.ChatInterface(             对话接口
        fn=echo                   指定函数
        type="messages"           指定传进来的history的格式{"role":"user/assistant","content":""}
        autofocus=True            让光标每次输出完就放在文本框中
        #如果为多模态聊天接口需要以下操作
        multimodel=True           此时message变为了一个字典{"Text":"","files":"单个文件路径"/["",""]（多个文件列表）}
        additional_intput=[]      允许加入额外的组件，记得也要在函数添加对应的参数
    )
4.block组件，低阶组件（可以自定义布局组件）

    1.基础组件
    with gr.Blocks as demo
        a1=gr.Textbox(label="标签")   文本框
        a2=gr.Button("按钮名字")       按钮
        a2.click(                    按钮绑定事件
            fn=
            intput=
            output=
        )
    2.布局组件
    gr.Row 将组件水平排列在同一行
    gr.Column 将组件垂直排在同一列
    gr.Group  将组件组成一个组
    gr.Tab    将组件分成不同的卡片组
    gr.Accordion    将组件页面折叠起来
    with gr.Blocks as demo
        with gr.Accordion(open=false)    一般默认关闭
            with gr.Tab("a1")
                with gr.Group
                    with gr.row()
                        gr.Tex()
                        gr.Tex()
                        gr.Tex()
                        with ge.Column
                        gr.Tex()
                        gr.Tex()
            with gr.Tab("a2")
                with gr.Group
                    with gr.row()
                        gr.Tex()
                        gr.Tex()
                        gr.Tex()
                        with ge.Column
                        gr.Tex()
                        gr.Tex()
    3.布局组件的常用属性
        scale：如果为0，就固定组件大小，一般还会设置一个min_width,来控制最小宽度，最大宽度随着内容改变
               如果设为不会为0的数，剩余组件会按照所设数值的大小，按照比例分配：
                a=Text(scale=1),b=Text(scale=3),c=Text(scale=0,min_width=20)
                a和b就会将除去c组件剩余的宽度空间，按照1:3的比例来分布。

        equal_height:值为bool值，控制（Row）内的组件等高。
                     gr.Row(equal_height=true)

        fill_height/fill_width:值为布尔值，True控制（blocks）内的组件高度/宽度占满整个block

    4.事件
        click：绑定一个组件，组件被点击后触发事件。
                接三个参数（fn，int组件，put组件），在blocks中事件可以随意匹配三个参数。
                a.click(fn1,int,put1)
                a.click(fn2,int,put2)
                a.click(fn2,int,put3)

        change：绑定一个组件，当其内容发生改变，就触发此事件
                a.change(fn,int,put)

        submit:绑定文本框组件，回车后触发事件
                a.submit(fn,int,put)

        then/success：连续触发事件，在基础事件执行完后，追加的组件
                then直接向下传递，success，无报错的情况下，才继续执行
                a.change(fn,int,put).then(fn,int,put).success(fn,int,put)

    ##事件修改组件属性：
        当事件返回值为一个包含属性的组件，其本质是将返回组件的属性赋给int组件
            eg:
            def a(v:bool,):
             return gr.Text(visible=v)

            int=gr.Checkbox()
            put=gr.Text()
            int.change(a,int,put)

            就会出现点击两次int单选框，就会出现put组件消失。























